import os
import cv2
import sys
import shutil
import numpy as np

from glob import glob
from multiprocessing import Pool
from sklearn.preprocessing import MinMaxScaler

RGB_64_FRAMES = 64
MAX_INT = sys.maxsize
base_path = os.path.join(os.getcwd(), 'videos')


def create_path(path):
    if not os.path.exists(path):
        os.makedirs(path)


def create_paths(base_path, activity):
    activity_path = os.path.join(base_path, activity)
    if os.path.exists(activity_path):
        print("Warning : ", activity_path, " existed")
        shutil.rmtree(activity_path)
    create_path(os.path.join(activity_path, '{}_rgb'.format(activity)))
    create_path(os.path.join(activity_path, '{}_flow'.format(activity), 'u'))
    create_path(os.path.join(activity_path, '{}_flow'.format(activity), 'v'))


def vid_to_image(base_path, file, frame_path, max_frame_count=MAX_INT):
    folder = file.split('.')[0]
    vidcap = cv2.VideoCapture(file)
    success, image = vidcap.read()
    count = 0
    frame_no = 0
    while success and count < max_frame_count:
        vidcap.set(1, frame_no)
        cv2.imwrite(os.path.join(frame_path, "frame%d.jpg") % count,
                    image)  # save frame as JPEG file
        success, image = vidcap.read()
        count += 1
        frame_no += 1
    return count


def cal_for_frames(video_path):
    frames = glob(os.path.join(video_path, '*.jpg'))
    frames.sort()
    flow = []
    prev = cv2.imread(frames[0])
    prev = cv2.cvtColor(prev, cv2.COLOR_BGR2GRAY)
    prev = cv2.resize(prev, (224, 224))
    for i, frame_curr in enumerate(frames):
        curr = cv2.imread(frame_curr)
        curr = cv2.resize(curr, (224, 224))
        curr = cv2.cvtColor(curr, cv2.COLOR_BGR2GRAY)
        tmp_flow = compute_TVL1(prev, curr)
        flow.append(tmp_flow)
        prev = curr
    return flow


def compute_TVL1(prev, curr, bound=15):
    """Compute the TV-L1 optical flow."""
    TVL1 = cv2.optflow.DualTVL1OpticalFlow_create()
    flow = TVL1.calc(prev, curr, None)
    flow = np.clip(flow, -20, 20)  #default values are +20 and -20
    assert flow.dtype == np.float32

    flow = (flow + bound) * (255.0 / (2 * bound))
    flow = np.round(flow).astype(int)
    flow[flow >= 255] = 255
    flow[flow <= 0] = 0
    return flow


def save_flow(video_flows, flow_path):
    #The optical flows are generated in 3D. However for I3D only first two channels are used. u is the first channel
    #and v is the second channel. Both u and v are saved in separate folders in the flow_path directory.
    #The u and v folders will be generated by calling create_path() function
    n_py = []
    for i, flow in enumerate(video_flows):
        cv2.imwrite(
            os.path.join(flow_path.format('u'), "{:06d}.jpg".format(i)),
            flow[:, :, 0])
        cv2.imwrite(
            os.path.join(flow_path.format('v'), "{:06d}.jpg".format(i)),
            flow[:, :, 1])
        n_py.append(np.dstack([flow[:, :, 0], flow[:, :, 1]]))
    return n_py


def norm_rgb(rgb_path, frame_path, nchannel, activity):
    ''' Create npy file for rgb files as described in deepmind I3D '''
    npy_file = []
    frames = glob(os.path.join(rgb_path, '*.jpg'))
    frames.sort()
    for frame in frames:
        try:
            img = cv2.imread(os.path.join(frame_path, frame))
            img_new = (cv2.resize(img, (224, 224))).astype(float)
            img_norm = np.divide(2 * (img_new - img_new.min()),
                                 (img_new.max() - img_new.min())) - 1
            npy_file.append(img_norm)
        except:
            continue
    npy_file = np.reshape(np.asarray(npy_file),
                          (1, len(frames), 224, 224, nchannel))
    file_path = os.path.join(base_path, activity,
                             'data_input_rgb_{}.npy'.format(activity))
    np.save(file_path, npy_file)
    return npy_file, file_path


def norm_flow(rgb_path, npy_flow, nchannel, activity):
    ''' Create npy file of flow files as described in deepmind I3D '''
    frames = glob(os.path.join(rgb_path, '*.jpg'))
    frames.sort()

    npy_file = np.reshape(
        np.asarray(npy_flow),
        (1, len(frames), 224, 224, nchannel - 1)).astype(float)
    npy_file = ((2 * (npy_file - npy_file.min()) /
                 (npy_file.max() - npy_file.min())) - 1)
    file_path = os.path.join(base_path, activity,
                             'data_input_flow_{}.npy'.format(activity))
    np.save(file_path, npy_file)
    return npy_file, file_path


def video_to_rgb_npy(file_path,
                     max_frame_count=RGB_64_FRAMES,
                     nchannel=3,
                     save_file=True):
    if not os.path.exists(file_path):
        print(file_path, "\nFile not exists\nDone\n")
        return False, None
    activity = os.path.basename(file_path).split(".")[0]
    base_path = os.path.join(os.path.dirname(file_path))
    vidcap = cv2.VideoCapture(file_path)
    npy_file = []
    success, image = vidcap.read()
    count, frame_no = 0, 0
    while success and count < max_frame_count:
        try:
            img_new = (cv2.resize(image, (224, 224))).astype(float)
            img_norm = np.divide(2 * (img_new - img_new.min()),
                                 (img_new.max() - img_new.min())) - 1
            npy_file.append(img_norm)
            vidcap.set(1, frame_no)
            success, image = vidcap.read()
            count += 1
            frame_no += 1
        except:
            continue
    if count != RGB_64_FRAMES:
        print(file_path, "\nFrames count incorrect : ", count)
        return False, None
    npy_file = np.reshape(np.asarray(npy_file), (1, count, 224, 224, nchannel))
    if save_file:
        create_path(os.path.join(base_path, activity))
        file_path = os.path.join(base_path, activity,
                                 'data_input_rgb_{}.npy'.format(activity))
        np.save(file_path, npy_file)
    return True, npy_file


def generate_rgb64_data(file_path):
    if not os.path.exists(file_path):
        print(file_path, "\nFile not exists\nDone\n")
        return 0, None
    activity = os.path.basename(file_path).split(".")[0]
    frame_path = os.path.join(base_path, activity, '{}_rgb'.format(activity))
    create_path(frame_path)
    #Convert your video to frames and save in to activity_rgb folder
    frame_count = vid_to_image(base_path, file_path, frame_path, RGB_64_FRAMES)
    if frame_count != 64:
        print(file_path, "\nframes count incorrect : ", frame_count)
    #generate npy files
    rgb_file, rgb_path = norm_rgb(frame_path, frame_path, 3, activity)
    return rgb_path


def generate_data(file_path):
    print("Processing ", file_path, "...")
    if not os.path.exists(file_path):
        print("File not exists\nDone")
        return 0, None, None
    activity = os.path.basename(file_path).split(".")[0]
    frame_path = os.path.join(base_path, activity, '{}_rgb'.format(activity))
    flow_path = os.path.join(base_path, activity, '{}_flow'.format(activity),
                             '{}'.format({}))
    create_paths(base_path, activity)

    #Convert your video to frames and save in to activity_rgb folder
    frame_count = vid_to_image(base_path, file_path, frame_path)

    #calculate flows
    flow = cal_for_frames(frame_path)
    #save flows to folders u and v
    npy_flow = save_flow(flow, flow_path)

    #generate npy files
    rgb_file, rgb_path = norm_rgb(frame_path, frame_path, 3, activity)
    flow_file, flow_path = norm_flow(frame_path, npy_flow, 3, activity)
    print("Done\n")

    return frame_count, rgb_path, flow_path